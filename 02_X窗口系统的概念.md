X窗口系统的概念
==============================
*Alan Coopersmith*

本章意在向你介绍X的基本概念和你所需要掌握的术语。当你理解这些概念后，你将能够在接下来的章节中进行更深入的学习。

<p>
<img src="./img/xorg.svg" width="80%" />
</p>

X是C/S（客户端/服务器）架构的
-----------------------------
X窗口系统设计来允许多个程序共同使用一个通用的硬件设置。这些硬件设备主要包括用于输入的鼠标和键盘，还有用于输出的显示适配器和连接它们的显示器。一个单独的进程用于控制这些硬件，供多个应用程序访问。这个控制进程叫做X服务器（X server），提供客户端程序硬件访问。大体上，X server提供的服务就是使得用户能够使用键盘、鼠标和显示器进行访问。

像很多C/S系统一样，X服务器一般也同时向多个客户端服务。X服务器运行的时间比绝大部分客户端要长，并且侦听新客户端的入栈连接。

很多用户只是单机地在笔记本电脑或者台式机上使用X。在这种设置下，X客户端和X服务器运行在同一个电脑上。但是，X还是为C/S式的交流定义了一个流协议。这个协议能穿越网络来让不同机器上的服务器和客户端能够通信。不幸的是，这种模式下，客户端和服务器的角色可能会被误解。也许你面前的笔记本电脑运行着X server，显示的图像却生成于一个位于远端机房的高性能计算机的X客户端上。对于大多数其他协议来说，如供文件分享的协议（http或者类似的协议），笔记本电脑应该是客户端。所以一定要搞清楚，**键盘和鼠标连接着X服务器**。它也是所有客户端连接的终点（比如终端窗口，网页浏览器，文本编辑器）。

X如何工作
---------
这一节描述了一些X的基本模块和它们具体如何工作。由于要一次性地把所用东西呈现出来，所以这节内容会有些混杂。建议先略读，回头再深入。

### 输入
像稍早提到过的一样，X服务器主要控制两种硬件：输入设备和输出设备。令人惊奇的是，输入控制由于其多源性、并发性、高度依赖于用户设置是两者中最难、最复杂的。。

#### 键盘输入
X服务器实现的一个任务是接受键盘的输入并且向正确的应用客户端发送对应的键盘输入事件。在一个简单的X配置下，若“输入焦点”位于某个客户端上，那么大多数键盘事件都会应用于这个客户端。取决于窗口管理器的设置，焦点可以通过点击鼠标、使用热键或是直接将鼠标移向别的窗口以及操作一个列举窗口的面板而向其他窗口转移。有焦点的客户端通常会以某种方式高亮，这样用户就能知道他们输入的信息去向何处。客户端能够使用“grabs”（将在这章后面一点的地方绍）来更改默认的键盘事件传递行为。

由于有不同语言，不同国家标准和硬件商对产品的差异化需求，世界上有很多种类的键盘类型。这种差异使得键盘事件从硬件“key codes”（键码）到文本输入的映射成为一个复杂且富有挑战的过程。当键盘上的键被按下时X服务器提供一个仅仅8bit的键码来记录按键并发射事件。X服务器也提供一个用于将Keycodes映射到“KeySyms”（KeySyms，键符号名，用于表示键盘上如“A”，“Enter”，“Shift”等的按钮的符号）上的键盘映射。键码在给定的环境外没有固定的意义，一个相同的按键也许会在不同的键盘、服务器、配置或者操作系统上形成不同的键码。KeySym则有全球统一的标准，是大多数的应用应该关心的。由于最初的协议中并没有定义如何处理额外的按键，X Keyboard（XKB）扩展提供了全面的设置和布局设置。Xlib和Toolkits也提供为高级的输入方式准备的输入方法，如组合键处理和将键盘序列映射到复杂的字符（比如亚洲语言的输入法）。

#### 鼠标输入
X协议定义了一个输入“指针”（不是编程概念“指针”）。这个指针在屏幕上表现为光标，它通常被鼠标或者类似的输入设备所控制。应用能够控制这个光标的图像。核心协议包含一个简单的两种颜色的光标的支持。Render扩展提供Alpha混合的32位色光标支持，这个支持一般从libXcursor中获得。

指针设备报告移动事件和按键事件并把事件发射到客户端。默认配置的Xorg服务器有一个单一的指针。这个指针将所有所有链接到服务器的指针类设备的移动事件和按键事件总和到一起：比如笔记本电脑的触摸板和USB外接鼠标。用户可以在Xinput 2.0扩展中用MultiPointer X（MPX）功能实现多个光标并将设备分配给每个光标。使用MPX时，每个指针有自己的焦点。每个指针和键盘一一绑定来让指针焦点所处的客户端接受输入。

#### 触摸板输入
就基础输入而言，对于客户端来说触摸板只是另一种移动指针和发生点击事件的设备。想要使用超过模拟鼠标功能的客户端可以使用Xinput 2.2扩展（随Xorg 1.12发布）或更高版本，以开启多点触控支持。

#### 触摸屏输入
[XXX write me --po8]
谁来写一下这一节？

#### 高级输入设备和技术
[Make whot write this? or steal from http://who-t.blogspot.com? --alanc]
哪个来写一下这儿嘛？要不然从http://who-t.blogspot.com 偷过来？

### GetImage: 从显示中直接读取信息
X服务器并不保它在显示输出中绘制了什么图像的记录。一旦二进制数据被渲染交给帧缓存（Frame Buffer），X服务器的使命就结束了。如果数据需要被再次渲染（比如，它们被暂时隐藏了），X服务器会让一个客户端——一般要么是一个合成管理器，要么是原本绘制这个数据的应用——来再次绘制它们。

某些情况下，最有代表性的就是当你使用“screenshots（截图）”功能时，某个客户端需要直接从Frame Buffer中取回内容。X协议提供一个GetImage请求来应对这种状况。

GetImage有很多缺点，建议不必要时应该尽量避免使用。现代图像技术中，因为硬件和软件被优化成输出像素和渲染像素的代价相同，使得GetImage成为了缓慢方式的典范。GetImage也很难被正确地使用。在这里，不同于X协议中的其他所有地方，底层硬件直接暴露在客户端面前。请求的帧缓存内容将和该帧缓存的所有队列、填充、字节顺序一起被发送给客户端。Xlib和XCB两个库中提供一些代码来将收到的帧缓存翻译成的有用信息。即使这样，使用这些代码还是会让处理变得更慢。

### 输出

#### 渲染和光栅化（Rendering/Rasterization）
X协议原生定义了一些核心的渲染操作，比方划线，多边形填充和复制图像缓存。但他们不随着图形硬件的发展和现代应用的需求而进化，所以现在只有很老的应用才使用它们。

现代应用使用多种客户端侧面渲染库，像Cairo来渲染2D图像或者OpenGL来渲染3D图像。它们也许把图像交给X服务器来显示，使用GPU加速的优点和别的硬件特性，或者使用DRI绕过X服务器直接和本地视频硬件进行交互。

##### 多边形渲染模型（Polygon Rendering Model）

### Displays and Screens
X把一个引擎的资源分配给显示和屏幕。显示通常是所有设备连接到一个X服务器，并且为单一用户显示一个单一的会话。系统也许会有多个显示，比如mulit-seat setups，甚至在系统控制台的多个虚拟终端。每个显示都有一套输入硬件配置和一个或者多个屏幕与之关联。屏幕是显示交叉的子集，窗口可以在显示交叉中移动或者显示，但是窗口不能跨越过多个屏幕或者从一个屏幕移动到另一个屏幕。输入设备可以在一个X Server的所有屏幕上进行交互，比如把鼠标从一个屏幕移动到另一个。最开始，每个屏幕都是只有单个监听器连接的单个独立的显示适配器，不过现代科技允许多个设备组合工作或者一个设备拆分工作。

当把一个客户端连接到X服务器上的时候，你必须要指定你要连接到的显示，要么通过$DISPLAY环境变量，要么通过应用的参数，比如-display或者--display。所有的语法都在man的X(7)页面中能够找到，但是典型的呈现语句是：hostname:display.screen。"hostname"在本地连接中也许会被忽略，而在使用默认屏幕时".screen"也会被忽略，剩下最小规格的display规范":display"，比如":0"在一个引擎上定义了普通默认的X Server。

### Graphics contexts
GC是一个为X绘制储存分享状态和公共值功能的结构，避免对相同参数作出复数回应。客户端可以按需分配附加的GC来实现通过为每个值的设置装配GC去指定不同的值然后只用为每个运算制定适当的GC。

### Colors (really?) and Visuals
X太老了，以至于它被设计出来时，大多数用户都还在使用黑白两色的可选的呈现，那时，硬件厂商甚至没有在黑0白1或者白0黑1上达成一致。花上额外一千美刀的人能拥有4或8bit的颜色，允许画板上有256种颜色。但现在已经是2012年了，大家电脑上都有32bit的颜色。不变的是，很多复杂的事依然存在而且某人必须解决它们。。。

### Syncing and Flushing connections
和描述通信章节一样，X也尽量通过异步来减少通信延时。这引起了使用渲染功能的码农们的注意，他们震惊于自己没有得到错误反馈但也没有看到期望的输出。那之后，绘制运算不用等待来自X Server的回应，它们仅仅寄存在客户端输出请求缓存里，并且，在缓冲被冲出之前都不会发送给X Server。在被充满后，缓存会自动被冲出，但是这要求很多命令来填满Xlib默认32kb的缓存空间。当一个为了等待来自X Server的响应的功能而阻塞时（虽然这些功能在Xlib和XCB这两种设计模式中是有区别的--详见Xlib和XCB章节），Xlib和XCB会冲出缓存。最终，客户端明确地调用Xlib中的XFlush()或者XCB中的xcbflush()来向Server发送所有缓存队列中的请求。为了在冲出缓存的同时等待来自X服务器完成处理这些请求，客户端能够使用Xlib中的XSync()或者XCB中的xcbaux_sync()。

### Window SYstem Objects
X中使用的令人眼花缭乱的对象。

#### Windows
在X中，一个窗口只是屏幕上一个会发生绘图的地方。窗口被存放在一个树状结构中，根窗口是一个服务器，它建立一个覆盖整个屏幕的面，并且在服务器运行时始终存在。其他所有窗口都是根窗或者别的窗口的子窗口。用户节目，比如大多数人想到的windows，只是窗口结构中的一级。

在每一级结构中，窗口有一个栈规则，用来控制两个同级窗口相互堆叠时如何显示。客户端可以为Visbility通知进行登记来得到窗口变得比以前更加或者更不显眼时的事件，这可用于优化实现只绘制窗口能见的部分。

当它的一部分窗口没有被覆盖但由于X服务器并不知道这里的内容是什么所以尚未被绘制时，运行在传统X环境下的客户端也会收到Expose事件。当合成扩展被启用时，因为合成功能把每个窗口的内容分开存放在不重叠不显示的缓存中并且随后混合每个窗口可见的部分来显示在屏幕上，客户端通常不会收到Expose事件。在将要被用于合成对比的传统环境时，客户端是不可控的，Expose事件一旦发生，它们必须准备处理窗口上的Expose事件。

#### Pixmaps(像素映射)
像素映射，就像窗口一样，是一个能发生绘制的地方。但与之不同的是，像素映射不是窗口树结构中的一部分，也不直接娴熟在屏幕上。像素映射的内容要么被复制到窗口上来进行显示，要么直接像CopyArea一样通过请求，或者自动通过设置窗口的背景来输出像素映射。像素映射也许会被储存在系统内存，显示适配器中的显存，或者客户端和服务器都能够使用的公共内存中。一个已经输出的像素映射也许会在系统和视频内存中徘徊,在更快的访问视频RAM中作为需要被维护的一个良好的最近访问像素应映射的高速缓冲。

#### Widgets(窗口小部件)
应用需要窗口和像素映射外的方法来提供用户接口-用户希望在窗口中看到菜单，案件，文本字段，等等。在大多数环境下，这些用户接口单元都使用窗口小部件。X不需要真正地在核心协议或者库中提供任何窗口小部件，只有阻塞，比如等待回应的方法和输入事件，才伴随着窗口小部件的建立。像Qt和GTK+这样的工具箱提供一个窗口小部件的公共设置来帮助程序建立它，并且，它们提供一个丰富的功能设置来广泛兼容用法和用户，包括读取不同语言，或者兼容更多你需要在应用中用到的科技。一些工具包已经通过把每个窗口小部件做成一个子窗口利用了X提供的所有关于窗口堆叠和位置基础设施，但是大多数现代的工具包不再服务器，而是在客户端实现这些功能。

#### XIDs
许多被服务器管理的资源被分配32-bit的身份认证号，在服务器端的命名空间中叫做XID。每个客户端在第一次连接服务器时被分配一段身份认证号范围，并且，每当它发送一个建立窗口，像素映射光标，或者别的被XID标记的资源请求时，客户端(通常在Xlib或者XCB库中是透明的)从它拥有的身份认证号中选择一个没有使用过的XID，并把它包含在给服务器的请求中以依照这个请求定义这个对象的建立。这使得更之后的请求在新的资源上运作，请求直接发送给服务器而不用等待服务器处理这个创建请求并返回一个资源id。因为命名空间在服务器上是全局变量，客户端可以从别的客户端处引用XID，比如把一个窗口移交给其他客户端。

#### Atoms(原子)
为了减少中公共串的转发，X引入了一个简单的查找表机构。表中的条目就是原子，并有一个已经被大多数需要使用到它协议操作遍历的整型键，和一个能够被检索的字符串。InternAtom以给定字符串找到原子的id，而且如果这个id不是既有的，它能可选的将字符串加入到表中并返回一个新的id。GetAtomName返回与给定原子id匹配的字符串。原子被广泛地应用到不同请求和事件当中，但有一个在给定X服务器上独立于所有运算和客户端的命名空间。

#### Properties(属性)
在X中，用来提供扩展元数据的公共设计就是属性引擎。属性是一个键的键值段，这类键是字符串时代表它是一个X原子并且它的值是也可能是一个原子，一个整型，或者别的类型值。核心协议提供窗口和字体的属性。Xinput扩展加入了输入设备的属性，Xrandr扩展加入了输出设备的属性。

X自身并不对窗口属性赋予任何意义或目的。但是约定还是规定了许多窗口属性怎样在窗口和会话中有效地帮助管理元数据。最开始，对属性的设置在ICCCM(the X Inter-Client Communication Conventions Manual)中有规定，你可以在http://www.x.org/releases/current/doc/ 中找到。这个初稿后来在freedesktop.org上被为现代桌面环境打造公共功能的团队所扩展，成为了EWMH(Extended Window Manager Hints)规范，可以在http://www.freedesktop.org/wiki/Specifications/wm-spec 中找到。

### Grabs(强占)
强占在X中提供锁定和保留功能。"Active Grabs"会立刻独占其给定的目标资源的使用权，并且将其他所有客户端锁在外面，直到grab释放它。"Passive Grabs"把一个预约存放在某个资源上，这会使当某事件发生时(比如按键)，出现一个"Active Grabs"。这可以用于实现用一个热键忽略当前的输入焦点来控制既定的应用。

活跃的强占之一是Server Grab。强占了服务器的客户端将其他客户端锁在外面，在Server Grab释放前防止别的应用更新显示或者影响用户。这中强占应该尽可能快地被释放，因为用户要是不能切换到别的程序中的话会觉得反人类，这也会造成很多安全问题，因为使用屏幕锁的只是一个客户端，却把剩下的客户端都锁住了。

其它强占的基本对象是输入设备和事件。得到了输入焦点的客户端可以积极地强占键盘和鼠标，即使光标移动到了这个应用的窗口外面。"Passive Grabs"可以被存放在一个特殊的输入事件中，比如一个特别的键入事件或者鼠标点击事件，事件发生时，它为当前客户端造成一个基本的强占以自动发生。

等多信息请查看http://who-t.blogspot.com/2010/11/high-level-overview-of-grabs.html 。

### Selections, Cut-Copy-Paste
[copy-and-paste from http://keithp.com/~keithp/talks/selection.ps and other docs on http://www.x.org/wiki/CutAndPaste ? ]
