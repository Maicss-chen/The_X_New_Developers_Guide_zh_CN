服务器和客户端间的通信
======================

*Alan Coopersmith*

虽然X客户端库和服务器封装了X协议编码、解码、传输的大部分细节，但是对此传输模型的基本理解对X客户端、服务器的开发和驱动程序的开发是必要的。

X客户端和服务器之间的通信是“全双工”的：任意一端都能随时向对方发送信息。这个特性是TCP/IP套接字接口提供的典型功能，但是X也常常使用许多其他的通信方式，如Unix Domain Sockets、命名管道和共享内存。通信方式必须提供可靠的、有序的字节流——因为X协议不提供记录或重发包的机制。如使用TCP/IP连接时，我们使用TCP协议而不是UDP协议。

X通信时传输的信息是由X11协议定义的。此协议于1987年发布。在过去的25年间，X11被大大的扩展了，但其核心协议仍旧和原版的定义相兼容。协议的细节详见：http://www.x.org/releases/current/doc/ 。

X协议的扩展机制是其一大关键特性。在核心协议为了向后兼容而很少改变的同时，大多数的改进都是通过协议上的可选扩展实现的。核心协议提供机制以列举和查询X服务器所支持的扩展，并能把这些扩展的产生消息加入到服务器和客户端交流的信息中。服务器的构建者可以选择所要支持的扩展，开发者能随着用途的扩展增加或者移除扩展而不必担心会打破核心协议的兼容性。客户端需要检查服务器是否支持它们所以来的扩展。如果一个扩展不可用（在某个适当的版本号上），客户端可以转而提供更精简功能的界面，或是直接报错退出：扩展不存在。

当X客户端刚连接到X服务器时，会有一个握手操作来确立连接的建立，并验证客户端是否有有连接的认证，设定一些通信参量如byte-endinanness（字节序）。早期，X认为服务器应该是一台高性能的机器，而客户端不是。有趣的是，客户端能让服务器提供它所需要的字节序，服务器将根据需要对请求和回复进行字节序交换（byte-swap）。

然后，客户端将向服务器发送请求，好让服务器向客户端提供一些信息。一般来说，客户端将请求堆积在缓存中，然后成批地发送它们，这使得通信和上下文切换更有效率。这样的缓存功能通常由Xlib和XCB提供给客户端；客户端需要时常刷新请求缓存来保证操作能被及时处理。

X服务器按照从客户端收到请求的顺序来处理他们。但是X服务器也随时对不同客户端发来的信息进行分类，所以并不能保证请求在不同客户端间保持一定顺序，除非有特殊的请求。服务器和客户端都记录当前的请求号，并将其作为每次请求的序号。

服务器将响应发给客户端。客户端发送的许多请求被X服务器直接处理掉，如果没有错误就没有任何返回。如果是要返回信息的请求，服务器就给客户端发送一个称为回复（reply）的响应。回复的序列号标明了它属于哪一个请求。客户端可能一次发送多条请求给X服务器，并异步地等待服务器的响应。回复会按顺序返回，但客户端需要记录自己发送请求的序号来将服务器的回复对应到相应请求上。
